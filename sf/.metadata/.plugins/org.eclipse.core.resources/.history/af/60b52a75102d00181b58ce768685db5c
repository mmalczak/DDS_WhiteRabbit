#include "xparameters.h"
#include "xil_printf.h"
#include "xil_io.h"

#include "my_regs.h"
#include "spi_general.h"
#include "spi_ADC.h"


#define DDS_BASE_FREQUENCY 244140
#define FREQ_MEAS_BASE_FREQUENCY 50000000
#define ADC_CLK_FREQUENCY 50000000
#define ADC_CLK_PERIOD 1/ADC_CLK_FREQUENCY




void setPLL2_RESET_N(u32 value)
{
	Xil_Out32(WBT_REG_PLL2_RESET_N, value);
}


void configure_AD9516(void);
void configure_AD9510_internal_signal(void);
void configure_AD9510_external_signal(void);
void configure_ADF4002(void);






void ppl1_syncb_on(u8 on)
{
	u32 a;
	a = Xil_In32(WBT_REG_PLL1_SYNCB);
	if(on==1)
	{
		Xil_Out32(WBT_REG_PLL1_SYNCB, a|(u32)1);
	}
	else
	{
		Xil_Out32(WBT_REG_PLL1_SYNCB, a&(u32)0xfffffffe);
	}
}
void led_on(u8 on)
{
	u32 a;
	a = Xil_In32(WBT_REG_LED);
	if(on==1)
	{
		Xil_Out32(WBT_REG_LED, 3);
	}
	else
	{
		Xil_Out32(WBT_REG_LED, 0);
	}
}

void setDDSStep(u32 step)
{
	Xil_Out32(WBT_REG_DDS, step);
}

void setDDSFrequency(u32 freq)
{
	u64 step = freq*(u64)262144;
	step = step/DDS_BASE_FREQUENCY;
	//step = step*1024;
	//printf("step = %d\n", (u32)step);

	if(freq<30000) xil_printf("Frequency to low\n\r");
	if(freq>80000000) xil_printf("Frequency to high\n\r");


	setDDSStep((u32)step);
}


void setFreqCounterMaskReg(u32 mask)
{
	Xil_Out32(WBT_REG_CNT_MASK, mask);
}


void measureDACPLLFreq(u32* freqDAC, u32* freqPLL)
{
	u32 countsDAC=0;
	u32 countsPLL=0;

	countsPLL=Xil_In32(WBT_REG_PLL_FREQ);
	countsDAC=Xil_In32(WBT_REG_DDS_FREQ);

	*freqDAC = (u32)(countsDAC*0.3725);
	*freqPLL = (u32)(countsPLL*0.3725);
}

void setReferencePLLCounter(u8 highCycles, u8 lowCycles)
{
	spi_send_data(0x004E, (lowCycles<<4)|highCycles, SPI_CS_AD9510_SEL);
	spi_send_data(0x0054, (lowCycles<<4)|highCycles, SPI_CS_AD9510_SEL);
	spi_send_data(0x005A, 0x01, SPI_CS_AD9510_SEL);
}


int main(void)
{
	AD95xx_spi_init();
	ADC_spi_init();
	setPLL2_RESET_N(1);
	u32 freqPLL, prFreqPLL;
	u32 freqDAC, prFreqDAC;

	char c;


	u32 freqDACSet=28000000;

	int diff, prDiff;
	int P=0, I=0, D=0;
	configure_AD9516();
	ppl1_syncb_on(1);
	configure_AD9510_internal_signal();
	setDDSFrequency(freqDACSet);
	setFreqCounterMaskReg((u32)0x04000000);

	for(int i=0; i<200000000; i++);
	measureDACPLLFreq(&freqDAC, &freqPLL);

	configure_ADF4002();
	spi_read_data(0x8000, 0x99, SPI_CS_AD9516_SEL);
/*
	u32 a=0;
	while(1)
	{

		prFreqDAC = freqDAC;
		measureDACPLLFreq(&freqDAC, &freqPLL);
		if(prFreqDAC != freqDAC)
		{

			diff=freqDAC - freqPLL;
			diff = diff/2;

			xil_printf("pll freq = %d \n\r", freqPLL);
			xil_printf("dac freq = %d \n\r", freqDAC);

			freqDACSet = freqDACSet - diff;
			setDDSFrequency(freqDACSet);
		}

	}
*/
/*
	while(freqDACSet>13000000)
	{
		freqDACSet-=10;
		for(int i=0; i<10000;i++);
		setDDSFrequency(freqDACSet);
		xil_printf("adc = %d \n\r", WB_SpiADC_Transfer());
	}
*/
	setReferencePLLCounter(8,8);

	while(1)
	{
		c=getchar();
		if(c!='\r')
		{
			switch(c)
			{
			case '9': freqDACSet++;break;
			case '8': freqDACSet--;break;
			case 'i': freqDACSet+=10;break;
			case 'u': freqDACSet-=10;break;
			case 'k': freqDACSet+=100;break;
			case 'j': freqDACSet-=100;break;
			case 'm': freqDACSet+=1000;break;
			case 'n': freqDACSet-=1000;break;
			case 'b': freqDACSet+=10000;break;
			case 'v': freqDACSet-=10000;break;
			default: xil_printf("Wrong value\n\r");break;
			}
			setDDSFrequency(freqDACSet);
			xil_printf("adc = %d \n\r", measure_ADC());
		}
	}

	xil_printf("pll freq = %d \n\r", freqPLL);
	xil_printf("dac freq = %d \n\r", freqDAC);
	xil_printf("diff freq = %d \n\r", diff);



	xil_printf("Sukces\n\r");

	return 1;
}





union
{
	struct
	{
		u32 controlBits:2;
		u32 counterReset:1;
		u32 powerDown1:1;
		u32 MUXOUT_CONTROL:3;
		u32 PD_polarity:1;
		u32 CP_threeState:1;
		u32 fastlockEnable:1;
		u32 fastlockMode:1;
		u32 timerCounterControl:4;
		u32 currentSetting1:3;
		u32 currentSetting2:3;
		u32 powerDown2:1;
	};
	struct
	{
		u32 initialization_function_Latch;
	};
}initialization_function_Latch;

union
{
	struct
	{
		u32 controlBits:2;
		u32 referenceCounter:14;
		u32 antiBacklashWidth:2;
		u32 testModeBits:2;
		u32 lockDetectPrecision:1;
	};
	struct
	{
		u32 referenceCounterLatch;
	};
}referenceCounterLatch;

union
{
	struct
	{
		u32 controlBits:2;
		u32 reserved:6;
		u32 Ncounter:13;
		u32 CPGain:1;
	};
	struct
	{
		u32 NCounterLatch;
	};
}NCounterLatch;



void configure_ADF4002(void)
{
	// initialization latch
	initialization_function_Latch.initialization_function_Latch=0;
	initialization_function_Latch.currentSetting2=0b100;
	initialization_function_Latch.currentSetting1=0b100;
	initialization_function_Latch.timerCounterControl=0b0011;
	initialization_function_Latch.PD_polarity=1;
	initialization_function_Latch.fastlockEnable=0;
	initialization_function_Latch.fastlockMode=0;
	initialization_function_Latch.MUXOUT_CONTROL=0b010;
	initialization_function_Latch.controlBits=0b11;
	spi_adf4002_send_data(initialization_function_Latch.initialization_function_Latch);

	//function latch
	initialization_function_Latch.controlBits=0b10;
	spi_adf4002_send_data(initialization_function_Latch.initialization_function_Latch);

	//reference counter latch
	referenceCounterLatch.referenceCounterLatch=0;
	referenceCounterLatch.referenceCounter=1<<6;
	spi_adf4002_send_data(referenceCounterLatch.referenceCounterLatch);

	//N counter latch
	NCounterLatch.NCounterLatch=0;
	NCounterLatch.Ncounter=1;
	NCounterLatch.controlBits=1;
	spi_adf4002_send_data(NCounterLatch.NCounterLatch);
}


